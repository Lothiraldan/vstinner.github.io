+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PEP 383: Non-decodable Bytes in System Character Interfaces
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

:date: 2018-03-15 16:00
:tags: cpython
:category: python
:slug: painful-history-python-filesystem-encoding
:authors: Victor Stinner

* June 2009: PEP 383, surrogateescape

**This article is the third in a series of articles telling the history and
rationale of the Python 3 Unicode model for the operating system:**

* 1. `Python 3.0 listdir() bug on undecodable filenames <{filename}/python30_listdir.rst>`_.
* 2. PEP 383
* 3. Painful history of the Python filesystem encoding

Start
=====

End of september 2008, **Martin v. Löwis** showed up and `proposed an idea
<https://bugs.python.org/issue3187#msg73992>` which will later become his
:pep:`383` "Non-decodable Bytes in System Character Interfaces":

    I'd like to propose yet another approach: make sure that conversion
    according to the file system encoding always succeeds. If an
    unconvertable byte is detected, map it into some private-use character.
    To reduce the chance of conflict with other people's private-use
    characters, we can use some of the plane 15 private-use characters, e.g.
    map byte 0xPQ to U+F30PQ (in two-byte Unicode mode, this would result in
    a surrogate pair).

    This would make all file names accessible to all text processing
    (including glob and friends); UI display would typically either report
    an encoding error, or arrange for some replacement glyph to be shown.

    There are certain variations of the approach possible, in case there is
    objection to a specific detail.

**Martin v. Löwis** wrote his :pep:`383` "Non-decodable Bytes in System
Character Interfaces" and implemented it in Python 3.1. The ``surrogateescape``
error handler fixed a lot of old and very complex Unicode issues on Unix.


