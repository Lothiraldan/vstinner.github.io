<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Victor Stinner blog 3</title>
        <link rel="stylesheet" href="https://vstinner.github.io/theme/css/main.css" />
        <link href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Victor Stinner blog 3 Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://vstinner.github.io/">Victor Stinner blog 3 </a></h1>
                <nav><ul>
                    <li><a href="https://vstinner.github.io/category/benchmark.html">benchmark</a></li>
                    <li><a href="https://vstinner.github.io/category/cpython.html">cpython</a></li>
                    <li><a href="https://vstinner.github.io/category/linux.html">linux</a></li>
                    <li><a href="https://vstinner.github.io/category/python.html">python</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html">Daemon threads and the Python finalization in Python 3.2 and 3.3</a></h1>
<footer class="post-info">
        <abbr class="published" title="2020-03-26T22:00:00+01:00">
                Published: jeu. 26 mars 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info --><p>At exit, the Python finalization calls Python objects finalizers (the
<tt class="docutils literal">__del__()</tt> method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.</p>
<p>This article covers bugs fixed in the Python finalization in Python 3.2 and
Python 3.3 (2009 to 2011), and a backport in Python 2.7.8 (2014).</p>
<a class="reference external image-reference" href="https://twitter.com/LuppiChan/status/1240346448606171136"><img alt="#CoronaMaison by Luppi" src="https://vstinner.github.io/images/coronamaison_luppi.jpg" /></a>
<p>Drawing: <a class="reference external" href="https://twitter.com/LuppiChan/status/1240346448606171136">#CoronaMaison by Luppi</a>.</p>
<div class="section" id="daemon-threads">
<h2>Daemon threads</h2>
<p>Python has a special kind of thread: &quot;daemon&quot; threads. The difference with
regular threads is that Python doesn't wait until daemon threads complete at
exit, whereas it waits until all regular (&quot;non-daemon&quot;) threads complete.
Example:</p>
<pre class="literal-block">
import threading, time
thread = threading.Thread(target=time.sleep, args=(5.0,), daemon=False)
thread.start()
</pre>
<p>This Python program spawns a regular thread which sleeps for 5 seconds. Python
takes 5 seconds to exit:</p>
<pre class="literal-block">
$ time python3 sleep.py

real   0m5,047s
</pre>
<p>If <tt class="docutils literal">daemon=False</tt> is replaced with <tt class="docutils literal">daemon=True</tt> to spawn a daemon thread
instead, Python exits immediately (57 ms):</p>
<pre class="literal-block">
$ time python3 sleep.py

real   0m0,057s
</pre>
<p>Note: The <tt class="docutils literal">Thread.join()</tt> method can be called explicitly to wait until a
daemon thread completes.</p>
</div>
<div class="section" id="don-t-destroy-the-gil-at-exit">
<h2>Don't destroy the GIL at exit</h2>
<p>In November 2009, <strong>Antoine Pitrou</strong> implemented a new GIL (Global Interpreter
Lock) in Python 3.2: <a class="reference external" href="https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f">commit 074e5ed9</a>.</p>
<p>In September 2010, he found a crash with daemon threads while stressing
<tt class="docutils literal">test_threading</tt>: <a class="reference external" href="https://bugs.python.org/issue9901">bpo-9901: GIL destruction can fail</a>. <tt class="docutils literal">test_finalize_with_trace()</tt> failed
with:</p>
<pre class="literal-block">
Fatal Python error: pthread_mutex_destroy(gil_mutex) failed
</pre>
<p>He pushed a fix for this crash in Python 3.2, <a class="reference external" href="https://github.com/python/cpython/commit/b0b384b7c0333bf1183cd6f90c0a3f9edaadd6b9">commit b0b384b7</a>:</p>
<pre class="literal-block">
Issue #9901: Destroying the GIL in Py_Finalize() can fail if some other
threads are still running.  Instead, reinitialize the GIL on a second
call to Py_Initialize().
</pre>
<p>The Python GIL internally uses a lock. If the lock is destroyed while a daemon
thread is waiting for it, the thread can crash. The fix is to <strong>no longer
destroy the GIL at exit</strong>.</p>
</div>
<div class="section" id="exit-the-thread-in-pyeval-restorethread">
<h2>Exit the thread in PyEval_RestoreThread()</h2>
<p>The Python finalization clears and deallocates the &quot;Python thread state&quot; of all
threads (in <tt class="docutils literal">PyInterpreterState_Delete()</tt>) which calls Python object
finalizers of these threads. Calling a finalizer can drop the GIL to call a
system call. For example, closing a file drops the GIL. When the GIL is
dropped, a daemon thread is awaken to take the GIL. Since the Python thread
state was just deallocated, the daemon thread crash.</p>
<p>This bug is a race condition. It depends on which order threads are executed,
on which order objects are finalized, on which order memory is deallocated,
etc.</p>
<p>The crash was first reported in April 2005: <a class="reference external" href="https://bugs.python.org/issue1193099">bpo-1193099: Embedded python thread
crashes</a>. In January 2008, <strong>Gregory P.
Smith</strong> reported <a class="reference external" href="https://bugs.python.org/issue1856#msg60014">bpo-1856: shutdown (exit) can hang or segfault with daemon
threads running</a>. He wrote a
short Python program reproducing the bug: spawn 40 daemon threads which do some
I/O operations and sleep randomly between 0 ms and 5 ms in a loop.</p>
<p><strong>Adam Olsen</strong> <a class="reference external" href="https://bugs.python.org/issue1856#msg60059">proposed a solution</a> (with a patch):</p>
<blockquote>
I think <strong>non-main threads should kill themselves off</strong> if they grab the
interpreter lock and the interpreter is tearing down. They're about to get
killed off anyway, when the process exits.</blockquote>
<p>In May 2011, <strong>Antoine Pitrou</strong> pushed a fix to Python 3.3 (6 years after the
first bug report) which implements this solution, <a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1">commit 0d5e52d3</a>:</p>
<pre class="literal-block">
Issue #1856: Avoid crashes and lockups when daemon threads run while the
interpreter is shutting down; instead, these threads are now killed when
they try to take the GIL.
</pre>
</div>
<div class="section" id="pyeval-restorethread-fix-explanation">
<h2>PyEval_RestoreThread() fix explanation</h2>
<p>The fix adds a new <tt class="docutils literal">_Py_Finalizing</tt> variable which is set by
<tt class="docutils literal">Py_Finalize()</tt> to the (Python thread state of the) thread which runs the
finalization.</p>
<p>Simplified patch of the <tt class="docutils literal">PyEval_RestoreThread()</tt> fix:</p>
<pre class="literal-block">
&#64;&#64; -440,6 +440,12 &#64;&#64; PyEval_RestoreThread()
         take_gil(tstate);
+        if (_Py_Finalizing &amp;&amp; tstate != _Py_Finalizing) {
+            drop_gil(tstate);
+            PyThread_exit_thread();
+        }
</pre>
<p>If Python is finalizing (<tt class="docutils literal">_Py_Finalizing</tt> is not NULL) and
<tt class="docutils literal">PyEval_RestoreThread()</tt> is called by a thread which is not thread running
the finalization, the thread exits immediately (call
<tt class="docutils literal">PyThread_exit_thread()</tt>).</p>
<p><tt class="docutils literal">PyEval_RestoreThread()</tt> is called when a thread takes the GIL.  Typical
example of code which drops the GIL to call a system call (close a file
descriptor, <tt class="docutils literal">io.FileIO()</tt> finalizer) and then takes again the GIL:</p>
<pre class="literal-block">
Py_BEGIN_ALLOW_THREADS
close(fd);
Py_END_ALLOW_THREADS
</pre>
<p>The <tt class="docutils literal">Py_BEGIN_ALLOW_THREADS</tt> macro calls <tt class="docutils literal">PyEval_SaveThread()</tt> to drop the
GIL, and the <tt class="docutils literal">Py_END_ALLOW_THREADS</tt> macro calls <tt class="docutils literal">PyEval_RestoreThread()</tt> to
take the GIL.  Pseudo-code:</p>
<pre class="literal-block">
PyEval_SaveThread();     // drop the GIL
close(fd);
PyEval_RestoreThread();  // take the GIL
</pre>
<p>With Antoine's fix, if Python is finalizing, a thread now exits immediately
when calling <tt class="docutils literal">PyEval_RestoreThread()</tt>.</p>
</div>
<div class="section" id="revert-take-gil-backport-to-2-7">
<h2>Revert take_gil() backport to 2.7</h2>
<p>In June 2014, <strong>Benjamin Peterson</strong> (Python 2.7 release manager) backported
Antoine's change to Python 2.7: fix included in 2.7.8.</p>
<p>Problem: the Ceph project <a class="reference external" href="https://tracker.ceph.com/issues/8797">started to crash with Python 2.7.8</a>.</p>
<p>In November 2014, the change was reverted in Python 2.7.9: see
<a class="reference external" href="https://bugs.python.org/issue21963">bpo-21963 discussion</a> for the rationale.</p>
<p>In 2014, I already wrote:</p>
<blockquote>
Anyway, <strong>daemon threads are evil</strong> :-( Expecting them to exit cleanly
automatically is not good. Last time I tried to improve code to cleanup
Python at exit in Python 3.4, I also had a regression (just before the
release of Python 3.4.0): see the <a class="reference external" href="https://bugs.python.org/issue21788">issue #21788</a>.</blockquote>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Daemon threads caused crashes in the Python finalization, first noticed in
2005.</p>
<p>Python 3.2 (released in February 2011) got a new GIL and also a bugfix for
daemon thread. Python 3.3 (released in September 2012) also got a bugfix for
daemon threads. The Python finalization became more reliable.</p>
<p>Changing Python finalization is risky. A backport of a bugfix into Python 2.7.8
caused a regression which required to revert the bugfix in Python 2.7.9.</p>
</div>
                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/python37-dev-mode.html" rel="bookmark"
                           title="Permalink to Python 3.7 Development Mode">Python 3.7 Development Mode</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-01-16T12:00:00+01:00">
                Published: jeu. 16 janvier 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/python.html">python</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info -->                <p>This article describes the discussion on the design of the <a class="reference external" href="https://docs.python.org/dev/using/cmdline.html#id5">development mode
(-X dev)</a> that I <strong>added
to Python 3.7</strong> and how it has been implemented.</p>
<p>The development mode enables runtime checks which are too expensive to be
enabled by default. It can be enabled by <tt class="docutils literal">python3 <span class="pre">-X</span> dev …</tt></p>
                <a class="readmore" href="https://vstinner.github.io/python37-dev-mode.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/cpython-pass-tstate.html" rel="bookmark"
                           title="Permalink to Pass the Python thread state explicitly">Pass the Python thread state explicitly</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-01-08T15:00:00+01:00">
                Published: mer. 08 janvier 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/python.html">python</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info -->                <div class="section" id="keeping-python-competitive">
<h2>Keeping Python competitive</h2>
<p>I'm trying to find ways to make Python more efficient for many years, see for
example my discussion at the Language Summit during Pycon US 2017: <a class="reference external" href="https://lwn.net/Articles/723949/">Keeping
Python competitive</a> (LWN article); <a class="reference external" href="https://github.com/vstinner/talks/blob/master/2017-PyconUS/summit.pdf">slides</a>.
At EuroPython 2019 (Basel), I gave the keynote &quot;Python Performance: Past,
Present and Future&quot;: <a class="reference external" href="https://github.com/vstinner/talks/blob/master/2019-EuroPython/python_performance.pdf">slides …</a></p></div>
                <a class="readmore" href="https://vstinner.github.io/cpython-pass-tstate.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/graphics-bugs-firefox-gnome.html" rel="bookmark"
                           title="Permalink to Graphics bugs in Firefox and GNOME">Graphics bugs in Firefox and GNOME</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-10-10T17:00:00+02:00">
                Published: jeu. 10 octobre 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/linux.html">linux</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/linux.html">linux</a> </p>
</footer><!-- /.post-info -->                <p>After explaining how to <a class="reference external" href="https://vstinner.github.io/debug-hybrid-graphics-issues-linux.html">Debug Hybrid Graphics issues on Linux</a>, here is the story of four graphics bugs
that I had in GNOME and Firefox on my Fedora 30 between May 2018 and September
2019: bugs in gnome-shell, Gtk, Firefox and mutter.</p>
<a class="reference external image-reference" href="https://www.flickr.com/photos/34298393&#64;N06/14488759356/"><img alt="Glitch" src="https://vstinner.github.io/images/glitch.jpg" /></a>
<div class="section" id="gnome-shell-freezes">
<h2>gnome-shell freezes</h2>
<p>In May 2018, six months after …</p></div>
                <a class="readmore" href="https://vstinner.github.io/graphics-bugs-firefox-gnome.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/debug-hybrid-graphics-issues-linux.html" rel="bookmark"
                           title="Permalink to Debug Hybrid Graphics issues on Linux">Debug Hybrid Graphics issues on Linux</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-09-11T15:50:00+02:00">
                Published: mer. 11 septembre 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/linux.html">linux</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/linux.html">linux</a> </p>
</footer><!-- /.post-info -->                <p><a class="reference external" href="https://wiki.archlinux.org/index.php/Hybrid_graphics">Hybrid Graphics</a> is a
complex hardware and software solution to achieve longer laptop battery life:
an <strong>integrated</strong> graphics device is used by default, and a <strong>discrete</strong>
graphics device with higher graphics performances is enabled on demand.</p>
<a class="reference external image-reference" href="https://www.theregister.co.uk/2010/02/09/inside_nvidia_optimus/"><img alt="Hybrid Graphics" src="https://vstinner.github.io/images/hybrid_graphics.jpg" /></a>
<p>If it is designed and implemented carefully, users should not notice that a
laptop …</p>
                <a class="readmore" href="https://vstinner.github.io/debug-hybrid-graphics-issues-linux.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/split-include-directory-python38.html" rel="bookmark"
                           title="Permalink to Split Include/ directory in Python 3.8">Split Include/ directory in Python 3.8</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-06-19T12:00:00+02:00">
                Published: mer. 19 juin 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/python.html">python</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/python.html">python</a> <a href="https://vstinner.github.io/tag/c-api.html">c-api</a> </p>
</footer><!-- /.post-info -->                <p>In September 2017, during the CPython sprint at Facebook, I proposed my
idea to create <a class="reference external" href="https://vstinner.github.io/new-python-c-api.html">A New C API for CPython</a>.
I'm still working on the Python C API at: <a class="reference external" href="http://pythoncapi.readthedocs.io/">pythoncapi.readthedocs.io</a>.</p>
<p>My analysis is that the C API leaks too many implementation details which
prevent to optimize Python …</p>
                <a class="readmore" href="https://vstinner.github.io/split-include-directory-python38.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/sys-unraisablehook-python38.html" rel="bookmark"
                           title="Permalink to Python 3.8 sys.unraisablehook">Python 3.8 sys.unraisablehook</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-06-15T01:00:00+02:00">
                Published: sam. 15 juin 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/python.html">python</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/python.html">python</a> </p>
</footer><!-- /.post-info -->                <p>I added a new <a class="reference external" href="https://docs.python.org/dev/library/sys.html#sys.unraisablehook">sys.unraisablehook</a> function to
allow to set a custom hook to control how &quot;unraisable exceptions&quot; are handled.
It is already testable in <a class="reference external" href="https://pythoninsider.blogspot.com/2019/06/python-380b1-is-now-available-for.html">Python 3.8 beta1</a>,
released last week!</p>
<p>An &quot;unraisable exception&quot; is an error which happens when Python cannot report
it to the caller. Examples …</p>
                <a class="readmore" href="https://vstinner.github.io/sys-unraisablehook-python38.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html" rel="bookmark"
                           title="Permalink to asyncio WSASend() memory leak">asyncio WSASend() memory leak</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-03-06T20:00:00+01:00">
                Published: mer. 06 mars 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>I fixed multiple bugs in asyncio <tt class="docutils literal">ProactorEventLoop</tt> previously. But test_asyncio
still failed sometimes. I noticed a memory leak in <tt class="docutils literal">test_asyncio</tt> which will
haunt me for 1 year in 2018...</p>
<p><strong>Yet another example of a test failure which looks harmless but hides a
critical bug.</strong> The bug is that sending a …</p>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html" rel="bookmark"
                           title="Permalink to asyncio: WSARecv() cancellation causing data loss">asyncio: WSARecv() cancellation causing data loss</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-31T15:20:00+01:00">
                Published: jeu. 31 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>In December 2017, <strong>Yury Selivanov</strong> pushed the long awaited <tt class="docutils literal">start_tls()</tt>
function.</p>
<p>A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of <tt class="docutils literal">SSLProtocol</tt> which will take 5 months of …</p>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html" rel="bookmark"
                           title="Permalink to Asyncio: Proactor ConnectPipe() Race Condition">Asyncio: Proactor ConnectPipe() Race Condition</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-30T18:00:00+01:00">
                Published: mer. 30 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (<a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html">Proactor Cancellation From Hell</a>), I fixed more race conditions
and bugs in <tt class="docutils literal">ProactorEventLoop</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">ConnectPipe()</tt> Race Condition</li>
<li>Race Condition in <tt class="docutils literal">BaseSubprocessTransport._try_finish()</tt></li>
<li>Close the transport on failure: ResourceWarning</li>
<li>Cleanup code …</li></ul>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 6
        <a href="https://vstinner.github.io/index2.html">&raquo;</a>
</p>
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://vstinner.readthedocs.org/">Victor Stinner's Notes</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://twitter.com/VictorStinner">Follow @VictorStinner on Twitter</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>